syntax = "proto3";
package gravity.v1;

import "cosmos/base/v1beta1/coin.proto";
import "cosmos_proto/cosmos.proto";
import "gravity/v1/gravity.proto";
import "gravity/v1/confirm.proto";
import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/cosmos/gravity-bridge/module/x/gravity/types";

// Msg defines the state transitions possible within gravity
service Msg {
  rpc Transfer(MsgTransfer) returns (MsgTransferResponse) {
    option (google.api.http).post = "/gravity/v1/transfer";
  }
  rpc CancelTransfer(MsgCancelTransfer) returns (MsgCancelTransferResponse) {
    option (google.api.http).post = "/peggy/v1/transfer/cancel";
  }
  rpc RequestBatch(MsgRequestBatch) returns (MsgRequestBatchResponse) {
    option (google.api.http).post = "/gravity/v1/request_batch";
  }
  rpc SubmitConfirm(MsgSubmitConfirm) returns (MsgSubmitConfirmResponse) {
    option (google.api.http).post = "/peggy/v1/confim";
  }
  rpc SubmitEvent(MsgSubmitEvent) returns (MsgSubmitEventResponse) {
    option (google.api.http).post = "/peggy/v1/event";
  }
  rpc SetDelegateKey(MsgDelegateKey) returns (MsgDelegateKeyResponse) {
    option (google.api.http).post = "/peggy/v1/delegate_keys";
  }
}

// MsgTransfer submits a transfer attempt to bridge an asset over to Ethereum.
// The transfer will be stored and then included in a batch and then
// submitted to Ethereum.
message MsgTransfer {
  // cosmos account address of the sender in bech32 format
  string sender = 1;
  // ethereum hex address of the recipient
  string eth_recipient = 2;
  // the SDK coin to send across the bridge to Ethereum. This can be either an
  // ERC20 token voucher or a native cosmos denomination (including IBC vouchers).
  cosmos.base.v1beta1.Coin amount = 3 [(gogoproto.nullable) = false];
  // the fee paid for the transaction relay accross the bridge to Ethereum.
  // NOTE: this is distinct from the Cosmos transaction fee paid, so a successful
  // transfer has two layers of fees for the user (Cosmos & Bridge).
  // TODO: specify if this needs to be an ERC20 or not.
  cosmos.base.v1beta1.Coin bridge_fee = 4 [(gogoproto.nullable) = false];
}

// MsgTransferResponse returns the transfer transaction ID which will be included
// in the batch tx.
message MsgTransferResponse {
  // transfer tx unique identifier
  bytes tx_id = 1 [
    (gogoproto.customname) = "TxID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
}

// MsgCancelTransfer allows the sender to cancel its own outgoing transfer tx
// and recieve a refund of the tokens and bridge fees. This tx will only succeed
// if the transfer tx hasn't been batched to be processed and relayed to Ethereum.
message MsgCancelTransfer {
  // transfer tx unique identifier
  bytes tx_id = 1 [
    (gogoproto.customname) = "TxID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  // cosmos account address of the sender in bech32 format
  string sender = 2;
}

message MsgCancelTransferResponse {}

// MsgRequestBatch requests a batch of transactions with a given coin denomination to send across
// the bridge to Ethereum.
message MsgRequestBatch {
  // cosmos account address of the orchestrator in bech32 format
  string orchestrator_address = 1;
  // coin denomination
  string denom = 2;
}

message MsgRequestBatchResponse {}

// MsgSubmitConfirm
message MsgSubmitConfirm {
  option (gogoproto.goproto_getters) = false;

  // confirmation for batch txs, logic call txs or signer sets
  google.protobuf.Any confirm = 1 [(cosmos_proto.accepts_interface) = "Confirm"];

  // cosmos account address of the orchestrator signer in bech32 format
  string signer = 2;
}

message MsgSubmitConfirmResponse {
  // confirm unique identifier
  bytes confirm_id = 1 [
    (gogoproto.customname) = "ConfirmID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
}

// MsgSubmitEvent
message MsgSubmitEvent {
  option (gogoproto.goproto_getters) = false;

  // event requested observed by a single validator orchestrator on Ethereum,
  // which will then need to be
  google.protobuf.Any event = 1 [(cosmos_proto.accepts_interface) = "EthereumEvent"];
  // cosmos account address of the orchestrator signer in bech32 format
  string signer = 2;
}

message MsgSubmitEventResponse {
  bytes event_id = 1 [
    (gogoproto.customname) = "EventID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
}

// MsgDelegateKey allows validators to delegate their voting responsibilities
// to a given orchestrator address. This key is then used as an optional
// authentication method for attesting events from Ethereum.
message MsgDelegateKey {
  // validator operator address in bech32 format
  string validator_address = 1;
  // cosmos account address of the orchestrator in bech32 format that
  // references the key that is being delegated to
  string orchestrator_address = 2;
  // ethereum hex address of the used by the orchestrator
  string eth_address = 3;
}

message MsgDelegateKeyResponse {}