syntax = "proto3";
package gravity.v1;

import "google/protobuf/timestamp.proto";
import "gogoproto/gogo.proto";
import "cosmos/base/v1beta1/coin.proto";

option go_package = "github.com/cosmos/gravity-bridge/module/x/gravity/types";

// Attestation is an event that is pending of confirmation by 2/3 of the signer set.
// The event is then attested and executed vy the state machine once the required
// threshold is met.
message Attestation {
  // event unique identifier
  bytes event_id = 1 [
    (gogoproto.customname) = "EventID",
    (gogoproto.casttype)   = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  // set of the validator operators address in bech32 format that attest in
  // favor of this event.
  repeated string votes = 2;
  // amount of voting power in support of this event execution
  int64 attested_power = 3;
  // height at which the event was attested an executed
  uint64 height = 4;
}

// DepositEvent is submitted when more than 66% of the active
// Cosmos validator set has claimed to have seen a deposit
// on Ethereum. ERC20 coins are minted to the receiver address
// address.
message DepositEvent {
  // event nonce for replay protection
  uint64 nonce = 1;
  // ethereum hex address of the contract
  string token_contract = 2;
  // amount of tokens deposited on Ethereum
  string amount = 3 [(gogoproto.customtype) = "github.com/cosmos/cosmos-sdk/types.Int", (gogoproto.nullable) = false];
  // ethereum sender address in hex format
  string ethereum_sender = 4;
  // cosmos bech32 account address of the receiver
  string cosmos_receiver = 5;
  // etherereum block height at which the event was observed
  uint64 ethereum_height = 6;
}

// WithdrawEvent claims that a batch of withdrawal
// operations on the bridge contract was executed.
message WithdrawEvent {
  // transaction identifier of the batch tx
  bytes tx_id = 1 [
    (gogoproto.customname) = "TxID",  
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  // event nonce of the batch tx on Cosmos
  uint64 nonce = 2;
  // ethereum hex address of the contract
  string token_contract = 3;
  // etherereum block height at which the event was observed
  uint64 ethereum_height = 4;
}

// LogicCallExecutedEvent describes a logic call that has been
// successfully executed on Ethereum.
message LogicCallExecutedEvent {
  // event nonce for replay protection
  uint64 nonce = 1;
  // invalidation ID allows to withdraw funds in case the logic call fails on the
  // ethereum side
  bytes  invalidation_id    = 2 [
    (gogoproto.customname) = "InvalidationID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
  // TODO: explain
  uint64 invalidation_nonce = 3;
  // etherereum block height at which the event was observed
  uint64 ethereum_height = 4;
}

// CosmosERC20DeployedEvent is submitted when an ERC20 contract
// for a Cosmos SDK coin has been deployed on Ethereum.
message CosmosERC20DeployedEvent {
  // event nonce for replay protection
  uint64 nonce = 1;
  // cosmos SDK coin denomination
  string cosmos_denom = 2;
  // ethereum ERC20 contract address in hex format
  string token_contract = 3;
  // name of the token
  string name = 4;
  // symbol or tick of the token
  string symbol = 5;
  // number of decimals the token supports (i.e precision)
  uint64 decimals = 6;
  // etherereum block height at which the event was observed
  uint64 ethereum_height = 7;
}

// EthereumInfo defines the latest observed ethereum block height and the
// corresponding timestamp value in nanoseconds.
message EthereumInfo {
  // timestamp in nanoseconds
  google.protobuf.Timestamp timestamp = 1 [(gogoproto.stdtime) = true, (gogoproto.nullable) = false];
  // ethereum block height
  uint64 height = 2;
}

// EthSigner represents a cosmos validator with its corresponding bridge operator
// ethereum address and its staking consensus power.
message EthSigner {
  // staking consensus power of the validator
  int64 power = 1;
  // bridge operator ethereum address in hex format
  string ethereum_address = 2;
}

// EthSignerSet is the Ethereum Bridge multisig set that relays transactions
// the two chains. The staking validators keep ethereum keys which are used to
// check signatures on Ethereum in order to get significant gas savings.
message EthSignerSet {
  // set of signers. Sorted by power
  repeated EthSigner signers = 1 [(gogoproto.castrepeated) = "EthSigners", (gogoproto.nullable) = false];
  // TODO: which height? cosmos? This should be the key
  uint64 height = 2;
}

// BatchTxInfo defines the key for a given batch transaction. It is used to map 
// a transfer tx identifier to the batch tx in which it's currently located in order
// to make user transfers easier to track.
message BatchTxInfo {
  // token contract of the transactions in the batch
  string token_contract = 1;
  // batch tx identifier
  bytes  id    = 2 [
    (gogoproto.customname) = "ID",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
}

// BatchTx represents a batch of transactions going from Cosmos to Ethereum. Batch
// txs are are identified by a unique hash and the token contract that is shared by
// all the transfer
message BatchTx {
  // tx nonce for replay protection
  uint64 nonce = 1;
  // timeout in seconds  // TODO: double check
  uint64 timeout = 2;
  // transaction identifiers of the transfer txs included in this batch
  repeated bytes transactions = 3 [(gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"];
  // ethereum contract address of the batch contract in hex format
  string token_contract = 4;
  // ethereum block height // TODO: double check
  uint64 block = 5;
}

// TransferTx represents an individual transfer from Cosmos to Ethereum
message TransferTx {
  // tx nonce for replay protection
  uint64 nonce = 1;
  // cosmos account address of the sender in bech32 format
  string sender = 2;
  // ethereum recipient address in hex format
  string ethereum_recipient = 3;
  // amount of the transfer represented as an sdk.Coin. The coin denomination
  // must correspond to a valid ERC20 token contract address
  cosmos.base.v1beta1.Coin erc20_token = 4 [(gogoproto.nullable) = false];
  // transfer fees for the bridge orchestrators, represented as an sdk.Coin.
  // The coin denomination must correspond to a valid ERC20 token contract address
  cosmos.base.v1beta1.Coin erc20_fee = 5 [(gogoproto.nullable) = false];
}

// LogicCallTx represents an individual arbitratry logic call transaction from
// Cosmos to Ethereum.
message LogicCallTx {
  // tx nonce for replay protection
  uint64 nonce = 1;
  // erc20 tokens represented as sdk.Coins
  repeated cosmos.base.v1beta1.Coin tokens = 2
      [(gogoproto.nullable) = false, (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  // erc20 tokens represented as sdk.Coins used as fees for the bridge orchestrators.
  repeated cosmos.base.v1beta1.Coin fees = 3
      [(gogoproto.nullable) = false, (gogoproto.castrepeated) = "github.com/cosmos/cosmos-sdk/types.Coins"];
  // ethereum contract address of the arbitrary logic contract in hex format
  string logic_contract_address = 4;
  // ABI payload of the smart contract function call
  bytes payload = 5;
  // timeout in seconds  // TODO: double check
  uint64 timeout = 6;
}

// TransactionIDs defines a protobuf message for storing transfer tx ids.
message TransactionIDs {
  // slice of transfer transaction identifiers
  repeated bytes ids = 1 [
    (gogoproto.customname) = "IDs",
    (gogoproto.casttype) = "github.com/tendermint/tendermint/libs/bytes.HexBytes"
  ];
}