syntax = "proto3";
package peggy.v1;

import "peggy/v1/genesis.proto";
import "peggy/v1/types.proto";
import "peggy/v1/msgs.proto";
import "peggy/v1/batch.proto";
import "cosmos_proto/cosmos.proto";

import "gogoproto/gogo.proto";
import "google/api/annotations.proto";
import "google/protobuf/any.proto";

option go_package = "github.com/althea-net/peggy/module/x/peggy/types";

// Query defines the gRPC querier service
service Query {
  // Params queries the parameters that a module is operating under
  rpc Params(QueryParamsRequest) returns (QueryParamsResponse) {
    option (google.api.http).get = "/peggy/v1beta/params";
  }

  // Valsets queries valsets in the store. If a nonce is not provided the latest valset is returned
  rpc Valsets(QueryValsetsRequest) returns (QueryValsetsResponse) {
    option (google.api.http).get = "/peggy/v1beta/valset";
  }

  // Confirms returns confirmations of a given type, requires nonce and/or address
  rpc Confirms(QueryConfirmsRequest) returns (QueryConfirmsResponse) {
    option (google.api.http).get = "/peggy/v1beta/{type}/confirm";
  }

  // PendingConfirm returns the last pending confirmation of a given type for a given address
  rpc PendingConfirm(QueryPendingConfirmRequest) returns (QueryPendingConfirmResponse) {
    option (google.api.http).get = "/peggy/v1beta/{type}/confirm/{address}/pending";
  }

  // Returns the last event nonce a given validator voted on
  rpc LastNonce(QueryLastNonceRequest) returns (QueryLastNonceResponse) {
    option (google.api.http).get = "/peggy/v1beta/nonce/{address}";
  }

  // Returns the outgoing tx batches available to be relayed
  rpc OutgoingTxBatches(QueryOutgoingTxBatchesRequest) returns (QueryOutgoingTxBatchesResponse) {
    option (google.api.http).get = "/peggy/v1beta/outgoingtx";
  }

  // Returns the outgoing logic calls available to be relayed
  rpc OutgoingLogicCalls(QueryOutgoingLogicCallsRequest) returns (QueryOutgoingLogicCallsResponse) {
    option (google.api.http).get = "/peggy/v1beta/outgoinglogic";
  }

  // Returns a batch request given a nonce
  // TODO: do we need this?
  rpc BatchRequestByNonce(QueryBatchRequestByNonceRequest) returns (QueryBatchRequestByNonceResponse) {
    option (google.api.http).get = "/peggy/v1beta/batch/{nonce}";
  }

  // ETHDenomToCosmosDenom
  rpc ERC20ToDenom(QueryERC20ToDenomRequest) returns (QueryERC20ToDenomResponse) {
    option (google.api.http).get = "/peggy/v1beta/cosmos_originated/erc20_to_denom";
  }

  // CosmosDenomToEthDenom
  rpc DenomToERC20(QueryDenomToERC20Request) returns (QueryDenomToERC20Response) {
    option (google.api.http).get = "/peggy/v1beta/cosmos_originated/denom_to_erc20";
  }

  // TODO: Simplify the key delegation querying
  rpc GetDelegateKeyByValidator(QueryDelegateKeysByValidatorAddress) returns (QueryDelegateKeysByValidatorAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_validator";
  }
  rpc GetDelegateKeyByEth(QueryDelegateKeysByEthAddress) returns (QueryDelegateKeysByEthAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_eth";
  }
  rpc GetDelegateKeyByOrchestrator(QueryDelegateKeysByOrchestratorAddress) returns (QueryDelegateKeysByOrchestratorAddressResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_delegate_keys_by_orchestrator";
  }

  rpc GetPendingSendToEth(QueryPendingSendToEth) returns (QueryPendingSendToEthResponse) {
    option (google.api.http).get = "/peggy/v1beta/query_pending_send_to_eth";
  }
}

// Params
message QueryParamsRequest {}
message QueryParamsResponse {
  Params params = 1 [(gogoproto.nullable) = false];
}

// Valsets
message QueryValsetsRequest {
  uint64 nonce = 1;
}
message QueryValsetsResponse {
  repeated Valset valsets = 1;
}

// Confirms
message QueryConfirmsRequest {
  ConfirmType type    = 1;
  uint64      nonce   = 2;
  string      address = 3;
}
message QueryConfirmsResponse {
  repeated google.protobuf.Any confirms = 1 [
    (cosmos_proto.accepts_interface) = "Confirm"
  ];
}

// PendingConfirm
message QueryPendingConfirmRequest {
  ConfirmType type    = 1;
  string      address = 2;
}
message QueryPendingConfirmResponse {
  google.protobuf.Any confirm = 1 [
    (cosmos_proto.accepts_interface) = "Confirm"
  ];
}

// LastNonce
message QueryLastNonceRequest {
  string address = 1;
}
message QueryLastNonceResponse {
  uint64 event_nonce = 1;
}

// OutgoingTxBatches
message QueryOutgoingTxBatchesRequest {}
message QueryOutgoingTxBatchesResponse {
  repeated OutgoingTxBatch batches = 1;
}

// OutgoingLogicCalls
message QueryOutgoingLogicCallsRequest {}
message QueryOutgoingLogicCallsResponse {
  repeated OutgoingLogicCall calls = 1;
}

message QueryBatchRequestByNonceRequest {
  uint64 nonce            = 1;
  string contract_address = 2;
}
message QueryBatchRequestByNonceResponse {
  OutgoingTxBatch batch = 1;
}

message QueryERC20ToDenomRequest {
  string erc20 = 1;
}
message QueryERC20ToDenomResponse {
  string denom             = 1;
  bool   cosmos_originated = 2;
}

message QueryDenomToERC20Request {
  string denom = 1;
}
message QueryDenomToERC20Response {
  string erc20             = 1;
  bool   cosmos_originated = 2;
}

message QueryDelegateKeysByValidatorAddress {
  string validator_address = 1;
}
message QueryDelegateKeysByValidatorAddressResponse {
  string eth_address          = 1;
  string orchestrator_address = 2;
}

message QueryDelegateKeysByEthAddress {
  string eth_address = 1;
}
message QueryDelegateKeysByEthAddressResponse {
  string validator_address    = 1;
  string orchestrator_address = 2;
}

message QueryDelegateKeysByOrchestratorAddress {
  string orchestrator_address = 1;
}
message QueryDelegateKeysByOrchestratorAddressResponse {
  string validator_address = 1;
  string eth_address       = 2;
}

message QueryPendingSendToEth {
  string sender_address = 1;
}
message QueryPendingSendToEthResponse {
  repeated OutgoingTransferTx transfers_in_batches = 1;
  repeated OutgoingTransferTx unbatched_transfers  = 2;
}
